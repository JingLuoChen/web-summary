/**
 *
 * 四次挥手：这由TCP的半关闭造成的
 *
 * 所谓半关闭：就是TCP提供了连接的一端在结束它的发送后还能接受来自另一端数据的能力
 *
 * 客户端和服务器均可主动发起挥手动作
 *
 */
//


/*
*
* 挥手过程：双方都处于ESTABLISHED状态（TCP连接状态）
*
* 第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号，此时客户端处于 FIN_WAIT1 状态
*
*           即 -> 发出连接释放报文段（FIN=1，序号seq=u),并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1状态，等待服务端的确认
*
*
*
* 第二次挥手：服务端收到FIN之后，会发送 ACK 报文，且把客户端的序号值+1 作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态
*
*           即 -> 服务端收到连接释放报文段后即发出确认报文段（ACK=1,确认号ack=u+1,序号seq=v）,服务端进入CLOSE_WAIT(关闭等待)状态，此时的TCP处于半关闭状态，
*
*           客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段
*
*
*
* 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号，此时服务端处于LAST_ACK的状态
*
*           即 -> 服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1,ACK=1,序号seq=w,确认号ack=u+1),服务端进入LAST_ACK状态，等待客户端的确认
*
*
*
* 第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务端的序列号值+1作为自己ACK报文的序列号值，此时客户端处于TIME_WAIT状态,
*
*           需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于CLOSED状态
*
*           即 -> 客户端收到服务器的连接释放报文段后，对此发出确认报文段（ACK=1,seq=u+1,ack=w+1）,客户端进入TIME_WAIT状态
*
* */


/*
*
* 为什么需要四次挥手？
*
* 关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET
*
* 所以会先回复一个ACK报文，告诉客户端，你发的FIN报文我收到了，只有等到服务端所有的报文都发送完了，我才能发送FIN报文
*
* 因次不能一起发送，需要四次挥手才行
*
* */
