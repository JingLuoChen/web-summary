# 面试总结
## http
### 基本状态码
```
500 服务开小差
504 请求超时
404 文件找不到
403 禁止访问
401 未授权
400 参数错误
302 临时重定向
301 永久重定向
200 成功
```
## 浏览器
### 重排、重绘
```
重排：即页面元素大小位置发生变化，即重新生成布局，重新排列元素
重绘：元素的外观被改变
```
### 数据存储
#### cookie、localstorage、sessionstorage 
```
cookie:
一般有服务端生成，可设置失效时间（一个月啥的），如果是从浏览器生成，那关闭浏览器之后就失效了
4kb左右
每次都会携带在Http头中，数据大的时候会有性能问题
应用场景：是否登录token验证

localstorage:
除非被清除，否则永久保存在浏览器中
5MB左右
仅在客户端保存，不会参与请求
应用场景：管理商购物车信息

sessionstorage:
存在于当前会话中，关闭页面或浏览器清空
5MBz左右
仅在客户端保存，不会参数请求
应用场景：页面表单提交，拆分多子页面
```
## css部分
### BFC的理解
内部子元素在怎么翻江倒海，也不会影响外部元素
```
触发条件
body 根元素
浮动元素 float 除 none 以外的值
定位元素 position (absolute、fixed)
display 为 inline-block、table-cells、flex
overflow 除了 visible 以外的值 (hidden、auto、scroll)
```
```
解决的问题
1、防止垂直方向的外边距重叠
2、防止元素被浮动元素所覆盖
3、防止高度塌陷 ---  清除浮动
```
### 隐藏/显示元素
```
不占位隐藏
display: block
display: none

占位隐藏
visibility: hidden
visibility: visibile
```

## js
### 浅拷贝Vs深拷贝
五种基本数据类型是存储在栈内存中的（栈内存中也存引用数据的在堆内存中的地址）<br>
引用数据类型是存储在堆内存中的
```
基本数据类型的赋值是 传值
引用数据类型的赋值是 传址 

浅拷贝和深拷贝只会在引用类型中发生

浅拷贝只是对对象的引用地址进行拷贝，新数据发生修改也会改变旧数据，共享一个内存地址
深拷贝是对对象复制并新生成一个对象，不共享一个内存地址

前拷贝一般都是直接赋值 对象和数组都是直接赋值的话就是浅拷贝
```



### 防抖、节流
```
相同点：都只在同一时间内执行一次
不同点：
防抖是延迟执行，每次触发都重置计时器 --- 理解：input不断输入，减少请求
节流是间隔执行，触发后在时间范围内再次触发则忽视 --- 理解：鼠标不断点击，但单位时间只一次有效
```


### this理解
````
函数中的this

函数直接调用 --- 函数内的this指向window，严格模式下是undefined

函数中对象中的this --- 指向window

对象中的方法 --- this一般指向调用该方法的对象，但当使用apply等会改变函数中this的指向

构造函数中的this --- this指向实例对象

箭头函数中的this --- 继承上下文的this
````

### apply、call、bind
手写源码
```js
function getSymbolName(context) {
    let unique = (Math.random() + new Date().getTime()).toString(32).slice(0, 8)
    if (context.hasOwnProperty(unique)) {
        return getSymbolName(context)
    } else {
        return unique
    }
}
Function.prototype.myCall = function (context) {
    context = context || window
    let fn = getSymbolName(context)
    context[fn] = this
    let arg = [...argument].slice(1)
    context[fn](...arg)
    delete context[fn]
}

Function.prototype.maApply = function(context) {
    context = context || window
    let fn = getSymbolName(context)
    context[fn] = this
    let arg = [...arguments].slice(1)
    context[fn](arg)
    delete context[fn]
}

Function.prototype.myBind = function(context) {
    context = context || window
    let arg1 = [...arguments].slice(1)
    return () => {
        let arg2 = [...arguments]
        return this.apply(context, arg1.concat(arg2))
    }
}

```

## ES6
### 箭头函数

## Vue
### 生命周期的理解
```
1、生命周期的理解
beforeCreate: 此时刚刚进行实例化对象，data和methods中都不能访问
created: 此时完成数据代理、初始化事件等，可以访问到data、methods
beforeMount: 此时已经完成在内存中生成模板字符串，以及完成虚拟dom
mounted: 此时已经把虚拟dom挂载到了页面上，此时可以操作dom元素进行相关操作
upforeUpdate: 此时data中的数据已经发生改变，
updated: 此时虚拟dom完成相关diff算法，同步到页面上
beforeDestroy: 此时实例还未进行销毁，还可以用this来获取实例
destroy: 此时实例已经被销毁

2、父子组件生成时经历的生命周期
生成阶段：父beforeCreate -> 父created -> 父beforeMounte -> 子beforeCreate -> 子created -> 子beforeMounte -> 子mounted -> 父mounted
父组件更新：父beforeUpdate -> 父updated
子组件更新：父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated

```

### computer和watcher的区别
```
computer是计算属性，会根据你所依赖的数据计算出新的结果，并且会缓存相应的计算结果，只要依赖的数据发生变化时才会重新计算

watch更像是对data的数据监听回调，当所监听的data数值发生变化时，会执行回调，方法中传入newVal和oldVal

总结：
如果一个数据是依赖于其他数据的话，就使用computed
如果你需要在某个数据发生变化时做一些事情，就使用watch

```

### 组件通信

### 路由$router和$route

### nextTick

### promise

### Vue.delete和delete 以及相关原理

### Vue.set


## 构建工具 webpack
### loader

### plugins


## 项目优化
