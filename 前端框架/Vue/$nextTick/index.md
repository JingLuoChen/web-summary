# Vue中的nextTick
## 概述
在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中

在created()钩子函数执行的时候DOM其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中，
与之对应的就是mounted()钩子函数，因为该钩子函数执行的时候所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题

在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中

## 为什么是nextTick
### 浏览器
浏览器(多线程)包含了**Browser进行**（浏览器的主要进程）、**第三方插件进程**和**GPU进程**（浏览器渲染进程），其中GPU进程和Web前端密切相关
* GUI渲染线程
* JS引擎线程
* 事件触发线程
* 定时触发器线程
* 异步HTTP请求线程

>GUI渲染线程和JS引擎线程是互斥的，为了防止DOM渲染的不一致性，其中一个线程执行时另一个线程会被挂起。

这些线程中，和Vue的nextTick息息相关的是JS引擎线程和事件触发线程

### Vue的API命名nextTick
Vue官方对nextTick这个API的描述：<br>
>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM

* 例子
```javascript
// 修改数据
vm.msg = 'Hello'
// DOM 还没有更新
Vue.nextTick(function () {
  // DOM 更新了
})

// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)
Vue.nextTick()
 .then(function () {
  // DOM 更新了
})
```

Vue异步执行DOM更新，只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个watcher被多次触发，
只会被推入到队列中一次。这种在缓冲时去处重复数据对于避免不必要的计算和DOM操作上非常重要。然后，在下一个的事件循环"tick"中，Vue刷新队列并执行
实际工作，Vue在内部尝试对异步队列使用原生的Promise.then和MessageChannel，如果执行环境不支持，会采用setTimeout(fn, 0)代替。

## 原理

Vue实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新。
```$xlst

异步执行的运行机制如下：

1、所有同步任务都在主线程上执行，形成一个执行栈
2、主线程之外，还存在一个'任务队列'，只要异步任务有了运行结果，就在'任务队列'之中放置一个事件
3、一旦'执行栈'中所有同步任务执行完毕，系统就会读取'任务队列'，看看里面有哪些事件，哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
4、主线程不断重复上面的第三步

```
## 作用

Vue.nextTick()用于延迟执行一段代码

## 参考文档

* [你真的理解$nextTick么](https://juejin.im/post/5cd9854b5188252035420a13)
* [Vue.nextTick 的原理和用途](https://segmentfault.com/a/1190000012861862)
* [简单理解Vue中的nextTick](https://juejin.im/post/6844903557372575752)
