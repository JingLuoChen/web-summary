# 动态规划
## 概述
动态规划有时为什么被认为是一种与递归相反的技术呢？

是因为递归是从顶部开始将问题分解，通过解决掉所有分解出小的问题的方式，来解决整个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，
然后合并成一个整体解决方案，从而解决掉整个大问题。

## 介绍
动态规划(简称DP)是算法设计思想当中最难也是最有趣的部分了，动态规划适用于有重叠子问题和最优子结构性质的问题，是一种在数学、计算机科学和经济学中经常使用的，
通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，使用动态规划方法解题有较高的时间效率，关键在于它减少了很多不必要的计算和重复计算的部分。

## 思想
它的思想就是把一个大的问题进行拆分，细分成一个个小的子问题，且能够从这些小的子问题的解当中推导出原问题的解，同时还需要满足以下两个重要性质才能进行动态规划

1、最优子结构性：既所拆分的子问题的解是最优解

2、子问题重叠性质：既在求解的过程当中，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次，动态规划算法正式利用了这种子问题重叠性质，对每一个子问题只计算一次，
然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的解题效率

## 实例
### 计算斐波那契数列
斐波那契数列可以定义为以下序列： 

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …

该数列是由前两项数值相加而成的


```js
// 递归的实现方式
function recurFib(n) {
    if (n < 2) {
        return n; 
    } else {
        
        return recurFib(n-1) + recurFib(n-2);
    } 
}
document.write(recurFib(10)); // 显示 55
```
在这个计算过程中，有太多值在递归调用中被重新计算，这也是递归方法效率低下的原因。

```js
// 动态规则的实现方法
function dynFib(n) {
    var val = [];
    for (var i = 0; i <= n; ++i) {
        val[i] = 0; 
    }
    if (n == 1 || n == 2) {
        return 1;
    } else {
        val[1] = 1;
        val[2] = 2;
        for (var i = 3; i <= n; ++i) {
            val[i] = val[i-1] + val[i-2];
        }
        return val[n-1];
    }
}
```

在这个数组val中保存了中间结果，如果要计算的斐波那契数是1或者2， 那么if语句会返回1。否则，数值1和2将被保存在val数组中1和2的位置。循环将会从3到输入的参数之间进行遍历，
将数组的每个元素赋值为前两个元素之和，循环结束，数组的最后一个元素值即为最终计算得到的斐波那契数值，这个数值也将作为函数的返回值。

斐波那契数列在数组val中的排列顺序如下

val[0] = 0 val[1] = 1 val[2] = 2 val[3] = 3 val[4] = 5 val[5] = 8 val[6] = 13

## 一维动态规则例子
假设你正在爬楼梯，需要10阶（不同于leetcode那种的n阶，暂时考虑为10），你才能到达楼顶

每次你可以爬1或者2个台阶，你有多少种不同的方法可以爬到楼顶呢？

* 采用动态规划来解决问题

动态规划类似于斐波，是自后往前考虑的。例如对于最后一步爬到第10阶楼梯有两种方法，从第9阶爬1阶，从第8阶爬2阶

那么到达第10阶的方法数等于到第9、第8阶之和。 即F(10) = F(9) + F(8)，F(9)与F(8)就是F(10)的最优子结构

对于第9阶，可以从第8阶、第7阶到第9阶，最优子结构F(9) = F(8) + F(7)

由此推导出公式：F(n) = F(n-1) + F(n-2)(n>=3)，这就是状态转移公式

边界：推导出公式至少要有两个数，那么取开始的情况F(2)=2，F(1)=1，从第0格到第1格爬1格，从第0格到第2格爬2格

```js
var climbStairs = function (n) {
    if (n === 1) { 
        return 1 
    } else if (n === 2) { 
        return 2 
    }
    return climbStairs(n - 1) + climbStairs(n - 2)
}
console.log(climbStairs(10)) //89
```

## 不同路径例子
一个机器人位于一个M*N网格的左上角，机器人每次只能向下或者向右移动一步，机器人视图达到网格的右下角，问总共有多少条不同的路径？

使用7X3的网格，按照动态规划从后向前推导，对于最后一格(7,3)有两种方式到达(6,3)向右一格，(7,2)向下一格

最优子结构：F(7,3) = F(6,3) + F(7,2)

状态转移公式：F(m,n) = F(m-1,n) + F(m,n-1)

限制条件：在最左边只能往右走，在上边只能往下走

边界：最左边只有一种走法，最上边也只有一种走法，F(x,1)=1，F(0,y)=1

```js
var uniquePaths = function (m, n) {
  if (m === 1 || n === 1) {
    return  1
  }
  return uniquePaths(m - 1, n) + uniquePaths(m, n - 1)
}
console.log(uniquePaths(7,3)) // 28
```

## 经典背包问题
一个小偷半夜进入商店抢劫，发现里面有很多值钱的东西，钻石珠宝等等，但是小偷只带了一个能装5kg的袋子，那么小偷能装的最多价值为多少？

id为物品id，value为物品价值，weight为物品种类，v/w为物品单位重量的价值，
````
id       1   2   3
value    6   10  12
weight   1   2   3
v/w      6   5   4 
````

此问题用动态规划的思想从前往后推导为：
1、袋子5kg，仅有第1个物品时怎么选收益最大

2、袋子5kg，有第1、2个物品时怎么选

3、袋子5kg，有第1、2、3个物品时怎么选

以上步骤分析为：

1、仅第1个物品时，判断1是否能放下，发现能，所以袋子中装入物品1，总价值为6

2、有1、2个物品时，判断是否需要装入2

```
// 判断条件为
// 1、选择装入物品2
select = 6
if (装入2) {
  // 装入2之后还有多少空间，这个空间下的最优解是什么
  装入2之后剩余空间为3，物品只有1，此时最优解为装1
  select = 6 + 10
}
notSelect = 6
// 2、不选择装入物品2
notSelect = 1价值
return max(select, notSelect)
```
在此情况为发现2可以装入，并且装入之后剩余空间仍为3，仍可装1，所以选择装入物品2，总价值为：1价值+2价值

3、有1、2、3个物品时是否需要装入3，上一步情况为装1、2总价值为16，如果装入3那么剩余空间为2，空间为2时的最优解是装入2。装3时共获取价值22，比不装好

在一维的思考中，每次加入一个物品这个物品都有两种选择：

1、不装，那么不装的最优解为之前的这个物品不存在时的最优解，例如步骤3，物品3参与选择时，最优解是空间5、物品[1，2]的最优解

2、装，例如步骤3，那么装的最优解就是装入3之后空间2、物品[1,2]时的最优解+3的价值

所以背包问题是一个二维的动态规划问题，不仅仅是物品维度，也是空间维度的

## 参考文档
* [JS基础--高级算法--动态规划](https://lilywei739.github.io/js/2018/03/09/AdvancedAlgorithms-1.html)
* [动态规划-js](https://www.jianshu.com/p/8ac893abf2ca)
