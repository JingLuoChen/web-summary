# 动态规划
## 概述
动态规划有时为什么被认为是一种与递归相反的技术呢？

是因为递归是从顶部开始将问题分解，通过解决掉所有分解出小的问题的方式，来解决整个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，
然后合并成一个整体解决方案，从而解决掉整个大问题。

## 介绍
动态规划(简称DP)是算法设计思想当中最难也是最有趣的部分了，动态规划适用于有重叠子问题和最优子结构性质的问题，是一种在数学、计算机科学和经济学中经常使用的，
通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，使用动态规划方法解题有较高的时间效率，关键在于它减少了很多不必要的计算和重复计算的部分。

## 思想
它的思想就是把一个大的问题进行拆分，细分成一个个小的子问题，且能够从这些小的子问题的解当中推导出原问题的解，同时还需要满足以下两个重要性质才能进行动态规划

1、最优子结构性：既所拆分的子问题的解是最优解

2、子问题重叠性质：既在求解的过程当中，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次，动态规划算法正式利用了这种子问题重叠性质，对每一个子问题只计算一次，
然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的解题效率

## 实例
### 计算斐波那契数列
斐波那契数列可以定义为以下序列： 

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …

该数列是由前两项数值相加而成的


```js
// 递归的实现方式
function recurFib(n) {
    if (n < 2) {
        return n; 
    } else {
        
        return recurFib(n-1) + recurFib(n-2);
    } 
}
document.write(recurFib(10)); // 显示 55
```
在这个计算过程中，有太多值在递归调用中被重新计算，这也是递归方法效率低下的原因。

```js
// 动态规则的实现方法
function dynFib(n) {
    var val = [];
    for (var i = 0; i <= n; ++i) {
        val[i] = 0; 
    }
    if (n == 1 || n == 2) {
        return 1;
    } else {
        val[1] = 1;
        val[2] = 2;
        for (var i = 3; i <= n; ++i) {
            val[i] = val[i-1] + val[i-2];
        }
        return val[n-1];
    }
}
```

在这个数组val中保存了中间结果，如果要计算的斐波那契数是1或者2， 那么if语句会返回1。否则，数值1和2将被保存在val数组中1和2的位置。循环将会从3到输入的参数之间进行遍历，
将数组的每个元素赋值为前两个元素之和，循环结束，数组的最后一个元素值即为最终计算得到的斐波那契数值，这个数值也将作为函数的返回值。

斐波那契数列在数组val中的排列顺序如下

val[0] = 0 val[1] = 1 val[2] = 2 val[3] = 3 val[4] = 5 val[5] = 8 val[6] = 13

## 寻找最长公共子串
用动态规划去寻找两个字符串的最长公共子串，例如，在单词"raven"和"havoc"，最长的公共子串是"av"。

### 原理
使用一个二维数组存储两个字符串相同位置的比较结果。初始化时，该数组的每一个元素被设置为0，每次在这两个数组的相同位置发现了匹配，就将数组对应行的元素加1，否则保持为0。
按照这种方式，一个变量会持续记录下找到了多少个匹配项，当算法执行完毕时，这个变量会结合一个索引变量来获取最长公共子串。

## 参考文档
* [JS基础--高级算法--动态规划](https://lilywei739.github.io/js/2018/03/09/AdvancedAlgorithms-1.html)
