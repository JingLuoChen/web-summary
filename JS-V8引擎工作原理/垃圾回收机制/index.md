# 垃圾回收机制
## 为什么会有垃圾回收
>由于字符、数组没有固定的大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。js在每一次创建字符串、数组、对象等时，解释器必须分配内存来存储那个实体。
只要分配了内容，最终都要释放，不然解释器将会消耗完系统中所有可用的内存。导致系统崩溃
## 内存泄漏（memory leak）
>程序的运行需要内存，只要程序提出要求，操作系统或者运行时，就必须提供内存，对于持续运行的服务进程，必须及时释放不再用到的内存
否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃
* 简单说就是不再被需要的内存，由于某种原因无法被释放

## 标记清除（mark-and-sweep）
### 执行机制
>当变量进入环境时，就将其标记为"进入环境"<br>
当变量离开环境时，就将其标记为"离开环境"<br>
逻辑上，永远不能释放进入环境的变量所占用的内存，因为执行流进入相应的环境时，可能会用到它们
### 标记清除采用的收集策略
> javaScript中的垃圾收集器运营时会给存储在内存中的所有变量都加上标记<br>
然后去掉环境中的变量以及被环境中的变量引用的变量的标记<br>
此后，在被加上标记的变量被视为准备删除的变量<br>
最后，垃圾收集器完成内存清除，销毁那些带标记的值并回收其占用的内存空间
```js
function func3 () {
  const a = 1
  const b = 2
  // 函数执行时，a b 分别被标记 进入环境
}
func3() // 函数执行结束，a b 被标记 离开环境，被回收
```
## 引用计数
### 实质
>跟踪记录每个值被引用的次数
### 执行机制
>当声明一个变量并将一个引用类型值赋值给该变量时，这个值的引用次数为1<br>
若同一个值（变量）又被赋值给另一个变量，则该值的引用次数加1<br>
但是如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1<br>
当这个值的引用次数为0时，则无法再访问这个值，就可回收其占用的内存空间

* 垃圾收集器下次运行时，会释放那些引用次数为零的值所占用的内存
```js
// 存在的致命问题：循环引用
function cycleRefernce() {
  const objectA = new Object()
  const objectB = new Object()
   
  objectA.someOtherObject = objectB
  objectB.anotherObject = objectA
}
```
上述代码中，两个对象之间相互引用，按照引用计数的策略，两个对象的引用次数都是2<br>
若采用标记清除策略，函数执行完毕，对象离开作用域就不存在相互引用<br>
但采用引用计数之后，函数执行完毕，对象的引用次数永远不为0，会一直存在内存中，若多次调用，导致大量内存得不到回收

### 解决
>为避免出现循环引用，最好在不使用这些对象时，手动断开，原生javaScript对象与DOM元素之间的连接
```js
// IE中的循环引用与手动断开的操作
const element = document.getElementById("some_element")
const myObject = new Object()
myObject.element = element
element.someObject = myObject
// 以上 存在循环引用
// ...... 
// 以下 手工断开连接
myObject.element = null
element.someObject = null
```
将变量设置为null，即可切断变量与它之前引用的值之间的连接，下次垃圾收集器运行时，会删除这些值并回收它们占用的内存
## 性能问题
垃圾收集器是周期运行的，确定垃圾收集的时间间隔是一个重要的问题
>IE7之前的垃圾收集器是根据内存分配量运行的，即256个变量，4096个对象（数组）字面量或64kb的字符串，达到这些临界值的任何一个，垃圾收集器就会运行，
所以就导致如果一个脚本含有很多变量，在整个生命周期中一直保有前面临界值大小的变量，就会频繁触发垃圾回收，会存在严重的性能问题

>IE7重写了垃圾收集例程，新的工作方式为：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。初始值与之前版本相同，但如果垃圾收集例程回收的内存低于15%，
则临界值加倍。若回收内存分配量超过85%，则临界值重置回默认值

## V8引擎的垃圾回收机制
### 分发回收机制
V8引擎将保存对象的堆（heap）进行了分代：
* 对象最初会被分在新生区（New Space）（1～8M），新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理（小周期），
清理掉新生区中不再活跃的死对象
* 对于超过2个小周期的对象，则需要将其移动至老生区，老生区在标记-清除或者标记-紧缩的过程中进行回收


## 参考文档
* [垃圾回收机制](https://github.com/PDKSophia/blog.io/blob/master/JavaScript%E7%AC%94%E8%AE%B0/JavaScript%E7%AF%87-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.md)
