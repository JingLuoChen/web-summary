# webpack
## 概述
自从出现模块化以后，大家可以将原本一坨代码分离到个个模块中，但是由此引发了一个问题。
每个 JS 文件都需要从服务器去拿，由此会导致加载速度变慢。Webpack 最主要的目的就是为了解决这个问题，
将所有小文件打包成一个或多个大文件，除此之外，Webpack 也是一个能让你使用各种前端新技术的工具。

webpack是一个现代javaScript应用程序的静态模块打包器，当webpack处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个bundle

## webpack是什么
webpack是一种前端资源构建工具，一个静态模块打包器。在webpack看来，前端的所有资源文件（js/json/css/img/less/...）都会作为模块处理。
它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源

例如浏览器不能识别less\es6语法等，需要使用webpack进行转换成浏览器能识别的语法

构建工具：就是整合所有的一系列转换工具<br>
静态模块打包器： 根据入口文件的依赖关系，将资源引进来，形成chunk代码块，根据不同资源进行编译(less->css、js高级语法->浏览器能识别的低级语法等等)，这个处理过程我们叫打包，打包输出的文件叫bundle<br>
chunk：代码块

## 前端构建工具--- 模块打包机
分析项目结构，找到JS模块以及其他一些浏览器不能直接运行的拓展语言scss、less，并将其转换和打包为合适的格式供浏览器使用

## Grant和Gulp工作方式
在一个配置文件中，指明对某些文件进行类似编译、组合、压缩等任务的具体步骤、工具之后可以自动替你完成这些任务

## Webpack工作方式
把项目当作一个整体，通过一个给定的主文件(index.js)，webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders来处理，最后打包为一个或多个浏览器可识别的js文件

* 结论对比：webpack的处理速度更快更直接，能打包多种不同类型的文件

* 工作流程

>1、参数解析<br>
2、找到入口文件<br>
3、调用loader编译文件<br>
4、遍历AST，收集依赖<br>
5、生成Chunk<br>
6、输出文件

其中真正起编译作用的便是Loader

## 功能
代码转换：TypeScript编译成JavaScript、SCSS、LESS编译成CSS
文件优化：压缩JavaScript、CSS、HTML代码，压缩合并图片
代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件
自动刷新：监听本地源代码的变化，自动重新构建，刷新浏览器
...

## webpack构建流程
webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

* 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数<br>
* 开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译<br>
* 确定入口：根据配置中的entry找出所有的入口文件<br>
* 编译模块：从入口文件出发，调用所有配置的loader对模块进行编译，再找出该模块依赖的模块，在递归本步骤直到所有入口依赖的文件都进过了本步骤的处理<br>
* 完成模块编译：在经过第4步使用loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系<br>
* 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，在把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会<br>
* 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，在文件内容写入到文件系统

在以上过程中名，Webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用Webpack提供的api改变Webpack的运行结果

简单说

* 初始化：启动构建，读取与合并配置参数，加载Plugin，实例话Compiler<br>
* 编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件的内容，再找到该Module依赖的Module，递归地进行编译处理<br>
* 输出：将编译后的Module组合成Chunk，将Chunk转换成文件，输出到文件系统中

## webpack的本质
webpack的本质上一种基于事件流的编程范例，其实就是一系列的插件运行

webpack主要使用compiler 和 compilation 两个类来控制webpack的整个生命周期，它们都继承了Tapabel并且通过Tapabel来注册了生命周期中的每一个流程需要触发的事件

## webpack的核心概念
entry：入口 <br>
output：输出 <br>
loader：模块转换器，用于把模块原有内容按照需求转换成新内容 <br>
plugin：扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情 <br>

## loader 和 plugin 的区别
loader本质就是一个函数，在该函数中对接受到的内容进行替换，返回转换后的结果。因为Webpack只认识JavaScript，所以loader就成了翻译官，对其他类型的资源进行转译的预处理工作

plugin就是插件，基于事件流框架Tapable，插件可以扩展Webpack的功能，在Webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过Webpack提供的api改变输出结果

loader在module.rules中配置，作为模块的解析规则，类型为数组，每一项都是一个Object，内部包含了test（类型文件）、loader、options（参数）等属性

plugin在plugins中单独配置，类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入

## 参考文档

* [带你深度解锁Webpack系列(基础篇)](https://juejin.cn/post/6844904079219490830)
* [带你走进webpack世界，成为webpack头号玩家。](https://juejin.cn/post/6844903588607557639)
* [一文掌握Webpack编译流程](https://mp.weixin.qq.com/s?__biz=MzI0MTUxOTE5NQ==&mid=2247484030&idx=1&sn=d630d4b3995bbfd50f99e781074acfeb)
* [webpack：从入门到真实项目配置](https://juejin.im/post/6844903495959576583)
* [「搞点硬货」从源码窥探Webpack4.x原理](https://juejin.cn/post/6844904046294204429)
