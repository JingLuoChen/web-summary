# 浏览器缓存机制（http缓存）
## 概述
* 缓存的机制原理：根据HTTP报文的缓存标识进行的。
* 缓存的目的：是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，
浏览器就可以从本地磁盘显示文档，这样就可以加速页面的浏览。
* 种类：浏览器缓存主要有两类：强制缓存：Expires 、cache-control 和 协商缓存：last-modified 、Etag。
* 释义：浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源，是浏览器将网络资源存储在本地的一种行为。浏览器的缓存机制是根据HTTP报文的缓存标识进行的。

## 缓存过程分析

1、浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存<br>

2、下一次请求资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，
不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1,则使用expires判断是否过期），如果时间过期，则向服务器发送header带有If-None-Match和
If-Modified-Since的请求。<br>

3、服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做过修改，Etag值一致则没有改变，命中协商缓存，返回304,如果不一致则有改动，
直接返回新的资源文件带上新的Etag值并返回200。<br>

4、如果浏览器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做对比，一致则命中协商缓存，返回304;
不一致则返回新的last-modified和文件并返回200

```$xslt
浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识

浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中
```

## 用户行为对浏览器缓存的控制
1、地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制。<br>
2、F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断。<br>
3、ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉去资源。

## 强制缓存
* 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程<br>

强制缓存的情况主要有三种

```$xslt
1、强制缓存失效，直接向服务器请求
不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求 --- 跟第一次发起请求一致

2、强制缓存失效，使用协商缓存
存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存

3、存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
```
### 强制缓存的缓存规则
当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文和HTTP头中  和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires 和 Cache-Control,
其中Cache-control优先级比Expires高

### Expires
Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果

```$xslt
HTTP/1.1中Expires已经被Cache-Control替代

原因：在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同等等）发生误差，那么强制缓存则会直接失效

这样的话强制缓存的存在就毫无意义了
```

### Cache-Control
```$xslt

在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存

public: 所有内容都将被缓存（客户端和代理服务器都可缓存）
private: 所有内容只有客户端可以缓存，Cache-Control的默认取值
no-cache: 客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
no-store: 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
max-age=xxx (xxx is numeric): 缓存内容将在xxx秒后过期

```
注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效


状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache<br>

![mahua](./img/cache-example.png)

* 内存缓存(from memory cache): 代表使用内存的缓存
```$xslt
快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取

时效性：一旦该进程关闭，则该进程的内存则会清空
```
* 硬盘缓存(from disk cache): 代表使用的硬盘中的缓存，浏览器读取缓存中的顺序为memory -> disk
```$xslt
 硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢
```

在浏览器中，浏览器会在js和图片等文件解析执行后直接存入缓存中，那么当刷新页面时只需要直接从内存缓存中读取<br>
而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存

#### 补充 
* 浏览器的缓存放在哪里，如何在浏览器中判断强制缓存是否生效？
>判断是否命中强制缓存：当命中强制缓存时，状态码为200，请求对应的Size值则代表该缓存存放的位置，分别为内存缓存和硬盘缓存

* 为什么CSS会放在硬盘缓存中？
>因为CSS文件加载一次就可渲染出来，我们不会频繁读取它，所以它不适合缓存到内存中，但是js之类的脚本却随时可能会执行，如果脚本在磁盘当中，我们在执行脚本的时候需要
从磁盘取到内存中来，这样I/O开销就很大了，有可能导致浏览器失去响应。

* 三级缓存原理（访问缓存优先级）
>1、先在内存中查找，如果有，直接加载。<br>
2、如果内存中不存在，则在硬盘中查找，如果有直接加载。<br>
3、如果硬盘中也没有，那么就进行网络请求。<br>
4、请求获取的资源缓存到硬盘和内存。

### 协商缓存
协商缓存就是强制失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

#### Etag和If-None-Match
Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。
浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接收到
If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。

#### Last-Modified和if-Modified-Since
last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，
放到request header里的If-Modified-Since里，服务器在接受到后也会做对比，如果相同则命中协商缓存。

#### Etag和Last-Modified区别
1、在方式上，Etag是对资源的一种唯一标识，而Last-Modified是该资源文件的最后一次的更改时间。<br>
2、在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在一秒内改变了多次，那么他们的Last-modified其实并没有体现出来修改，
但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-modified也有可能不一致。<br>
3、在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>
4、在优先级上，服务器校验优先考虑Etag。

## 总结
强制缓存优先于协商缓存进行，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果
在存入浏览器中，生效则返回304,继续使用缓存


## 参考文档
* [彻底了解浏览器缓存机制](https://juejin.im/entry/5ad86c16f265da505a77dca4)
* [浏览器的缓存机制](https://bbs.huaweicloud.com/blogs/163604)
