# 闭包
### 匿名函数
> 匿名函数: 顾名思义就是没有名字的函数<br>
匿名函数的调用方式:<br>
1、将匿名函数用()括起来<br>
2、然后在后面加一对小括号(包含参数列表)

```$xslt
即: (function(){})() 或者 (function(){}())   -> 自执行的匿名函数

为什么(function(){})() 可以被执行，而function(){}() 却报错

分析：

1、(function(){}) 是表达式，function(){}是函数声明
2、javaScript在'预编译'阶段，会解释函数声明，但却忽略表达式
3、当js执行到function(){}()时，由于function(){}在'预编译'阶段已经被解释过，js会跳过function(){},试图去执行(),故会报错
4、当js执行到(function(){})()时，由于(function(){})是表达式，js会去对它求解得到返回值，由于返回值是一个函数，故而遇到(),便会被执行


函数转换为表达式的方法不一定要靠分组操作符()，也可以使用void操作符、～操作符、！操作符、、、、
即 ～function(){}() 也是自执行的匿名函数
```
------------------------------------------------------------------
## 闭包
> 闭包是指有权访问另一个函数作用域的变量的函数 <br>
创建闭包的常用方式就是一个函数内部创建另一个函数

```js
  function fn1() {
    var n = 1;

    return function() {
        alert(n);
    }
  }
  result = fn1();
  result(); // -> 输出1
  
  // 闭包的作用
  // 1、读取函数内部的变量
  // 2、将变量的值始终保存在内存中
``` 
### 补充---函数作用域
>具体的概念上面已经讲述到，下述为理解的想法：<br>
 1、作用域的概念，可以认为它是一个封闭的空间，只允许在这个封闭的空间内进行一些操作<br>
 2、在javaScript中，一个函数的执行就会在内存中创建一个私有作用域 --- 封闭的空间<br>
 3、当函数执行完成之后，这个私有作用域(封闭的空间)就会销毁<br>
 4、但闭包是不会销毁的

### 补充---内存回收机制
```$xslt
内存回收机制就是不在用到的内存，系统就自动进行回收从而清理出空间供给其他程序使用

回收的规则: 当某一变量或者对象引用着，在回收的时候就不会释放它，因为被引用代表着被使用，回收器不会对正在引用的变量或对象进行回收的
```
### 补充---作用域继承
```$xslt
所谓作用域继承，就像是儿子可以继承父亲的财产一样。
在javaScript中，在一个函数里边我们在声明一个函数，内部函数可以访问外部函数作用域的变量，而外部的函数不能访问内部函数的作用域变量
```
* 综上所述，闭包的作用域是不会被回收销毁的

## 闭包的应用场景
```$xslt
1、解决for循环中的重复绑定问题 -> 此为经典的闭包面试题
  for(let i = 0; i < 5; i++) {
    setTimeout(() => {
      console.log(i)
    }, 100)
  }
  // 即输出的都是 6 6 6 6 6
    
  // 原因: setTimeout为异步执行 for循环为同步代码 且 i为全局变量 当执行setTimeout时 i为for循环结束后的5 即一直输出的都是5
  // 解决: 使用闭包，形成块级作用域
  for(let i = i; i < 5; i++) {
    ~function(i){      
     setTimeout(() => {
       console.log(i)
     }, 100)     
    }(i)
  }
  // 即 输出的是 1 2 3 4 5 
```
```$xslt
2、ES5中实现封装模块的功能
  let moduleA = (function funA(){
    var a=2;
    var b=3;
    function getA(){
      console.log(a);
    }
    function getB(){
      console.log(b);
    }
    return {
      getA,
      getB   // -> 对象的增强写法
    }
  })()
  moduleA.getA();
  moduleA.getB();
  
  // 此方法可以实现在ES5中封装模块，但方法的问题是模块变量不能互相引用以及内存泄漏问题
  // ES6出现的 export 和 inport 来导出和导入模块 当然也需要webpack进行转换成浏览器可以实现的语法
  // CommonJS中的 export 和 require 是基于Node环境实现的模块封装 使用需使用webpack转换为浏览器可以识别的语法
```

------------------------------------------------------------------
## 内存泄漏（memory leak）

* 程序的运行需要内存，只要程序提出要求，操作系统就必须提供内存，对于持续运行的服务进程，必须及时释放不再用到的内存，否则内存占用越来越高，轻则影响系统性能，重则导致进程崩溃

* 闭包的缺点: 即 内存泄漏，因为闭包中的内存，是一种不能被销毁的私有作用域，回收器不会对正在引用的变量或对象进行回收

